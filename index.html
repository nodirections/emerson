<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hydrometric Water Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Optionally set the station here (one of several ways to supply it) -->
  <!-- <meta name="station" content="05OC001"> -->

  <style>
    body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    h2 { text-align:center; margin: 16px 8px; }
    #gageChart { width: min(1100px, 92vw); height: 520px; margin: 0 auto 24px; }
    .note { text-align:center; color:#555; margin-bottom: 12px; }
  </style>
</head>

  <script>
    // ====== DYNAMIC STATION/MODE DETECTION ======
    function detectStation() {
      // 1) meta[name="station"]
      const m = document.querySelector('meta[name="station"]');
      if (m?.content?.trim()) return m.content.trim().toUpperCase();

      // 2) data-station on <body> or <html>
      const ds = document.body?.dataset?.station || document.documentElement?.dataset?.station;
      if (ds?.trim()) return ds.trim().toUpperCase();

      // 3) query string ?station=05OC001
      const url = new URL(window.location.href);
      const q = url.searchParams.get('station');
      if (q?.trim()) return q.trim().toUpperCase();

      // 4) hash #05OC001
      const h = url.hash?.replace(/^#/, '').trim();
      if (h && /^[0-9A-Z]{2}[A-Z]{2}[0-9]{3}$/i.test(h)) return h.toUpperCase();

      // 5) filename pattern: index-05OC001.html, 05OC001.html, etc.
      const file = (url.pathname.split('/').pop() || '').trim();
      const mFile = file.match(/(?:^|[-_])([0-9A-Z]{2}[A-Z]{2}[0-9]{3})(?:\.[a-z]+)?$/i);
      if (mFile) return mFile[1].toUpperCase();

      // 6) path segment …/05OC001/…
      const parts = url.pathname.split('/').filter(Boolean);
      for (const p of parts) {
        if (/^[0-9A-Z]{2}[A-Z]{2}[0-9]{3}$/i.test(p)) return p.toUpperCase();
      }

      return null; // no station detected
    }

    function detectMode() {
      // ?mode=daily → daily mean; anything else → realtime last 30 days
      const url = new URL(window.location.href);
      const mode = (url.searchParams.get('mode') || '').toLowerCase();
      return mode === 'daily' ? 'daily' : 'realtime';
    }

    // ====== CONFIG (DYNAMIC) ======
    const STATION = detectStation() || '05OC001'; // default if nothing supplied
    const MODE = detectMode(); // 'realtime' or 'daily'
    const USE_HISTORICAL_DAILY_MEAN = MODE === 'daily';

    // Optional: station-specific flood bands (only applied if defined for the station)
    const PLOT_BANDS_BY_STATION = {
      '05OC001': [
        { from: 228.05, to: 228.9, color: 'rgba(0, 128, 0, 0.20)', label: { text: 'Channel Capacity' } },
        { from: 229.0, to: 230.0, color: 'rgba(0,   0,255, 0.20)', label: { text: 'Minor Flood Level' } },
        { from: 230.5, to: 230.7, color: 'rgba(255,255,  0, 0.20)', label: { text: 'Moderate Flood Level' } },
        { from: 230.9, to: 231.0, color: 'rgba(255,200,  0, 0.20)', label: { text: 'Major Flood Level' } },
        { from: 231.2, to: 231.9, color: 'rgba(255,  0,  0, 0.40)', label: { text: 'Severe Flood Level' } }
      ]
    };

    // ====== DATA HELPERS ======
    async function fetchAllPages(firstUrl, maxPages = 500) {
      let url = firstUrl;
      const all = [];
      const seen = new Set();
      let loops = 0;

      while (url && !seen.has(url) && loops < maxPages) {
        seen.add(url); loops++;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status} on ${url}`);
        const geojson = await resp.json();
        if (Array.isArray(geojson.features)) all.push(...geojson.features);

        const nextLink = (geojson.links || []).find(l => l.rel === 'next' && l.href);
        url = nextLink ? new URL(nextLink.href, resp.url).href : null; // resolve relative links
      }
      return all;
    }

    function buildRealtimeUrl(station) {
      const end = new Date();
      const start = new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000);
      const datetime = `${start.toISOString()}/${end.toISOString()}`;
      const p = new URLSearchParams({
        STATION_NUMBER: station,
        datetime,
        f: 'json',
        lang: 'en-CA',
        limit: '10000'
      });
      return `https://api.weather.gc.ca/collections/hydrometric-realtime/items?${p.toString()}`;
    }

    function buildDailyMeanUrl(station) {
      const p = new URLSearchParams({
        STATION_NUMBER: station,
        f: 'json',
        lang: 'en-CA',
        limit: '10000'
      });
      return `https://api.weather.gc.ca/collections/hydrometric-daily-mean/items?${p.toString()}`;
    }

    function buildStationsInfoUrl(station) {
      const p = new URLSearchParams({
        STATION_NUMBER: station,
        f: 'json',
        lang: 'en-CA',
        limit: '1'
      });
      return `https://api.weather.gc.ca/collections/hydrometric-stations/items?${p.toString()}`;
    }

    function parseDateString(raw, isDaily) {
      if (!raw) return NaN;
      const s = String(raw).trim();
      if (isDaily) {
        if (s.length === 10) return Date.parse(`${s}T00:00:00Z`);
        return Date.parse(s.includes('T') ? s : s.replace(' ', 'T'));
      } else {
        const iso = s.includes('T') ? s : s.replace(' ', 'T');
        return Date.parse(iso);
      }
    }

    function toSeries(features, timeField, valueField, isDaily) {
      const pts = [];
      for (const f of features) {
        const tRaw = f?.properties?.[timeField];
        const v = parseFloat(f?.properties?.[valueField]);
        const ts = parseDateString(tRaw, isDaily);
        if (!Number.isNaN(v) && !Number.isNaN(ts)) pts.push([ts, v]);
      }
      pts.sort((a, b) => a[0] - b[0]);
      return pts;
    }

    async function fetchStationLabel(station) {
      try {
        const url = buildStationsInfoUrl(station);
        const feats = await fetchAllPages(url, 2);
        const props = feats?.[0]?.properties || {};
        // Prefer OFFICIAL_NAME if present; fallback to WATERCOURSE_NAME or STATION_NAME
        const primary =
          props.OFFICIAL_NAME || props.WATERCOURSE_NAME || props.STATION_NAME || '';
        return String(primary || '').trim();
      } catch {
        return '';
      }
    }

    async function loadAndRender() {
      try {
        // figure out dataset
        let url, timeField, titleSuffix, seriesName, isDaily;
        if (USE_HISTORICAL_DAILY_MEAN) {
          url = buildDailyMeanUrl(STATION);
          timeField = 'DATE';
          seriesName = 'Daily Mean Level';
          titleSuffix = ' (Daily Mean • Full Record)';
          isDaily = true;
        } else {
          url = buildRealtimeUrl(STATION);
          timeField = 'DATETIME';
          seriesName = 'Water Level';
          titleSuffix = ' (Instantaneous • Last 30 days)';
          isDaily = false;
        }

        // parallel fetch: data + station label
        const [features, stationLabel] = await Promise.all([
          fetchAllPages(url),
          fetchStationLabel(STATION)
        ]);

        const seriesData = toSeries(features, timeField, 'LEVEL', isDaily);
        if (!seriesData.length) throw new Error('No valid data points parsed from API response.');

        // Titles
        const niceTitle = stationLabel
          ? `Water Level at ${stationLabel} (${STATION})`
          : `Water Level (${STATION})`;
        document.getElementById('chartTitle').textContent = niceTitle;
        document.getElementById('subtitle').textContent =
          'Drag to zoom • Double‑click to reset';

        // Plot bands (only if we have definitions for this station)
        const plotBands = PLOT_BANDS_BY_STATION[STATION];

        // ---- Highcharts ----
        Highcharts.chart('gageChart', {
          chart: { type: 'line', zoomType: 'x' },
          title: { text: `${niceTitle}${titleSuffix}` },
          subtitle: { text: 'Drag to zoom • Double‑click to reset' },
          xAxis: { type: 'datetime', title: { text: 'Date' } },
          yAxis: {
            title: { text: 'Water Level (m)' },
            plotBands: plotBands
          },
          tooltip: {
            xDateFormat: isDaily ? '%Y-%m-%d' : '%Y-%m-%d %H:%M',
            valueDecimals: 2,
            valueSuffix: ' m'
          },
          credits: { enabled: false },
          series: [{ name: seriesName, data: seriesData, color: '#1f78b4', lineWidth: 1.5 }]
        });
      } catch (err) {
        console.error('Error:', err);
        document.getElementById('subtitle').textContent = '';
        document.getElementById('gageChart').innerHTML =
          '<p style="color:#b00; text-align:center;">Error loading data. Open the console for details.</p>';
      }
    }

    // ====== Load Highcharts with fallback, then start ======
    (function loadHighchartsAndStart() {
      const start = () => {
        const t0 = Date.now();
        (function wait() {
          if (window.Highcharts) return loadAndRender();
          if (Date.now() - t0 > 15000) {
            console.error('Highcharts failed to load within 15s.');
            document.getElementById('gageChart').innerHTML =
              '<p style="color:#b00; text-align:center;">Highcharts failed to load (CDN blocked?).</p>';
            return;
          }
          setTimeout(wait, 50);
        })();
      };

      const s1 = document.createElement('script');
      s1.src = 'https://code.highcharts.com/11.4.8/highcharts.js';
      s1.defer = true;
      s1.onload = start;
      s1.onerror = () => {
        const s2 = document.createElement('script');
        s2.src = 'https://cdn.jsdelivr.net/npm/highcharts@11.4.8/highcharts.min.js';
        s2.defer = true;
        s2.onload = start;
        s2.onerror = () => {
          document.getElementById('gageChart').innerHTML =
            '<p style="color:#b00; text-align:center;">Unable to load Highcharts from either CDN.</p>';
        };
        document.head.appendChild(s2);
      };
      document.head.appendChild(s1);
    })();
  </script>
</body>
</html>



