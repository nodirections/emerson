<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Manitoba Hydrometric Stations â€“ Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .leaflet-popup-content { font: 14px/1.35 system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    .btnrow { display:flex; gap:8px; margin-top:8px; }
    .btnrow a { display:inline-block; padding:6px 10px; border-radius:8px; text-decoration:none; border:1px solid #ccc; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // Point the popup links to your chart page.
    // (You could also keep this as "./" to link to index.html in the same folder.)
    const LINK_BASE = "https://nodirections.github.io/emerson/";

    // Province filter (MB)
    const PROVINCE = "MB";

    function ecccStationsUrl(prov, limit = 10000) {
      const p = new URLSearchParams({
        PROV_TERR_STATE_LOC: prov,
        f: "json",
        lang: "en-CA",
        limit: String(limit)
      });
      return `https://api.weather.gc.ca/collections/hydrometric-stations/items?${p}`;
    }

    async function fetchAllPages(firstUrl, maxPages = 50) {
      let url = firstUrl;
      const all = [];
      const seen = new Set();
      let loops = 0;
      while (url && !seen.has(url) && loops < maxPages) {
        seen.add(url); loops++;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status} on ${url}`);
        const geojson = await resp.json();
        if (Array.isArray(geojson.features)) all.push(...geojson.features);
        const next = (geojson.links || []).find(l => l.rel === "next" && l.href);
        url = next ? new URL(next.href, resp.url).href : null;
      }
      return all;
    }

    function stationLabel(p) {
      return (p?.OFFICIAL_NAME || p?.WATERCOURSE_NAME || p?.STATION_NAME || "").toString().trim();
    }

    function popupHtml(p) {
      const id = (p?.STATION_NUMBER || "").toString().trim();
      const name = stationLabel(p);
      const watercourse = (p?.WATERCOURSE_NAME || "").toString().trim();

      const title = name ? `${name} (${id})` : id;
      const wc = watercourse ? `<div><strong>Watercourse:</strong> ${watercourse}</div>` : "";

      const rtUrl = new URL(LINK_BASE);
      rtUrl.searchParams.set("station", id);

      const dailyUrl = new URL(rtUrl.href);
      dailyUrl.searchParams.set("mode", "daily");

      return `
        <div>
          <div style="font-weight:600">${title}</div>
          ${wc}
          <div class="btnrow">
            <a href="${rtUrl.href}" target="_blank" rel="noopener">Open chart (realtime)</a>
            <a href="${dailyUrl.href}" target="_blank" rel="noopener">Open chart (daily)</a>
          </div>
        </div>`;
    }

    (async function init() {
      const map = L.map("map", { preferCanvas: true });
      const mbCenter = [54.7, -97.5];
      map.setView(mbCenter, 5);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      try {
        const feats = await fetchAllPages(ecccStationsUrl(PROVINCE));
        const group = L.featureGroup();

        for (const f of feats) {
          const coords = f?.geometry?.coordinates;
          const props = f?.properties || {};
          if (!Array.isArray(coords) || coords.length < 2) continue;
          const [lon, lat] = coords;
          const m = L.marker([lat, lon]).bindPopup(popupHtml(props));
          group.addLayer(m);
        }

        group.addTo(map);
        if (group.getLayers().length) {
          map.fitBounds(group.getBounds().pad(0.1));
        }
      } catch (e) {
        console.error(e);
        alert("Failed to load hydrometric stations. See console for details.");
      }
    })();
  </script>
</body>
</html>
