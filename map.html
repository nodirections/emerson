<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Manitoba Hydrometric Stations â€“ Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    #err { position: fixed; inset: auto 8px 8px 8px; background:#fee; color:#900; padding:8px; border:1px solid #c99; border-radius:6px; font: 13px/1.35 system-ui, Segoe UI, Roboto, Arial, sans-serif; display:none; }
    .leaflet-popup-content { font: 14px/1.35 system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    .btnrow { display:flex; gap:8px; margin-top:8px; }
    .btnrow a { display:inline-block; padding:6px 10px; border-radius:8px; text-decoration:none; border:1px solid #ccc; }
  </style>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map"></div>
  <div id="err"></div>

  <!-- Leaflet JS (no SRI to avoid hash mismatches) -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
  (function(){
    const showErr = (msg) => {
      const el = document.getElementById('err');
      el.textContent = msg;
      el.style.display = 'block';
      console.error(msg);
    };

    // Where your chart lives (this is YOUR URL)
    const LINK_BASE = "https://nodirections.github.io/emerson/";

    const PROVINCE = "MB";

    function ecccStationsUrl(prov, limit = 10000) {
      const p = new URLSearchParams({
        PROV_TERR_STATE_LOC: prov,
        f: "json",
        lang: "en-CA",
        limit: String(limit)
      });
      return `https://api.weather.gc.ca/collections/hydrometric-stations/items?${p}`;
    }

    async function fetchAllPages(firstUrl, maxPages = 50) {
      let url = firstUrl;
      const all = [];
      const seen = new Set();
      let loops = 0;
      while (url && !seen.has(url) && loops < maxPages) {
        seen.add(url); loops++;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status} on ${url}`);
        const geojson = await resp.json();
        if (Array.isArray(geojson.features)) all.push(...geojson.features);
        const next = (geojson.links || []).find(l => l.rel === "next" && l.href);
        url = next ? new URL(next.href, resp.url).href : null;
      }
      return all;
    }

    function stationLabel(p) {
      return (p?.OFFICIAL_NAME || p?.WATERCOURSE_NAME || p?.STATION_NAME || "").toString().trim();
    }

    function popupHtml(p) {
      const id = (p?.STATION_NUMBER || "").toString().trim();
      const name = stationLabel(p);
      const watercourse = (p?.WATERCOURSE_NAME || "").toString().trim();

      const title = name ? `${name} (${id})` : id;
      const wc = watercourse ? `<div><strong>Watercourse:</strong> ${watercourse}</div>` : "";

      const rtUrl = new URL(LINK_BASE);
      rtUrl.searchParams.set("station", id);

      const dailyUrl = new URL(rtUrl.href);
      dailyUrl.searchParams.set("mode", "daily");

      return `
        <div>
          <div style="font-weight:600">${title}</div>
          ${wc}
          <div class="btnrow">
            <a href="${rtUrl.href}" target="_blank" rel="noopener">Open chart (realtime)</a>
            <a href="${dailyUrl.href}" target="_blank" rel="noopener">Open chart (daily)</a>
          </div>
        </div>`;
    }

    window.addEventListener('DOMContentLoaded', async () => {
      try {
        if (!window.L) { showErr("Leaflet failed to load."); return; }

        const map = L.map('map', { preferCanvas: true });
        const mbCenter = [54.7, -97.5];
        map.setView(mbCenter, 5);

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18,
          attribution: "&copy; OpenStreetMap contributors"
        }).addTo(map);

        let feats;
        try {
          feats = await fetchAllPages(ecccStationsUrl(PROVINCE));
        } catch (e) {
          showErr("Failed to load hydrometric stations. See console for details.");
          console.error(e);
          return;
        }

        if (!Array.isArray(feats) || feats.length === 0) {
          showErr("No stations returned for MB. (API may be temporarily unavailable.)");
          return;
        }

        const group = L.featureGroup();
        for (const f of feats) {
          const coords = f?.geometry?.coordinates;
          const props = f?.properties || {};
          if (!Array.isArray(coords) || coords.length < 2) continue;
          const [lon, lat] = coords;
          const m = L.marker([lat, lon]).bindPopup(popupHtml(props));
          group.addLayer(m);
        }
        group.addTo(map);

        if (group.getLayers().length) {
          map.fitBounds(group.getBounds().pad(0.1));
        } else {
          showErr("Loaded the feed but found zero valid station points.");
        }
      } catch (e) {
        showErr("An unexpected error occurred. Open the browser console for details.");
        console.error(e);
      }
    });
  })();
  </script>
</body>
</html>
